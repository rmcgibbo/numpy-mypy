from typing import (Any, Callable, Dict, Generic, Iterator, List, Optional, Sequence, Tuple, Type, Text,
                    TypeVar, Union, Sized, Iterable, SupportsInt, SupportsFloat, overload, SupportsAbs)

class dtype: ...
_dtype = dtype

int32 = Generic[int]


class flagsobj:
    """numpy.flagsobj"""
    aligned = None       # type: bool
    behaved = None       # type: bool
    c_contiguous = None  # type: bool
    carray = None        # type: bool
    contiguous = None    # type: bool
    f_contiguous = None  # type: bool
    farray = None        # type: bool
    fnc = None           # type: bool
    forc = None          # type: bool
    fortran = None       # type: bool
    owndata = None       # type: bool
    updateifcopy = None  # type: bool
    writeable = None     # type: bool
    def __getitem__(self, item: str) -> bool: ...
    def __setitem__(self, item: str, value: bool) -> None: ...

#
# Type variables. _T wasn't used to avoid confusions with ndarray's "T" attribute.
#
_X = TypeVar('_X')
_Y = TypeVar('_Y')

class _Dimension: ...
class ZeroD(_Dimension): ...
class OneD(_Dimension): ...
class TwoD(_Dimension): ...
class ThreeD(_Dimension): ...
class FourD(_Dimension): ...
class _InferNdimsReduction(Generic[_X]): ...
class _InferNdimsFromShape: ...
class _InferNdimsDiagonal(Generic[_X]): ...
class _ToggleDims_12_21(Generic[_X]): ...
class _InferNdimsIfAxisSpecified(Generic[_X, _Y]): ...
class _InferDtype: ...
class _InferDtypeWithDefault(Generic[_X]): ...
class _RaiseDim(Generic[_X]): ...
class _LowerDim(Generic[_X]): ...
class _LowerDim2(Generic[_X]): ...
class _UfuncCast(Generic[_X, _Y]): ...
class _LargestDim(Generic[_X, _Y]): ...


_S = TypeVar('_S', covariant=True)
_S1 = TypeVar('_S1', covariant=True)
_D = TypeVar('_D', covariant=True)
_D1 = TypeVar('_D1', covariant=True)


#
# Auxiliary types
#
class _DtypeTypeSingleton: ...
class _ShapeTypeSingleton: ...
class _AxesTypeSingleton: ...
class _AxisTypeSingleton: ...
class _KeepDimsSingleton: ...

ShapeType = Union[int, Sequence[int], _ShapeTypeSingleton]
AxesType = Union[None, int, Tuple[int, ...], _AxesTypeSingleton]
AxisType = Union[None, int, _AxisTypeSingleton]
OrderType = Union[str, Sequence[str]]
DtypeType = Union[dtype, type, str, _DtypeTypeSingleton]
KeepDimsType = Union[bool, _KeepDimsSingleton]
EllipsisType = object

_IndexType = Union[int, List[int], EllipsisType, slice, None, 'ndarray[int, Any]', 'ndarray[bool, Any]',]
IndexType = Union[_IndexType, Tuple[_IndexType, ...]]

scalar = Union[float, int, bool]


class flatiter(Generic[_S], Iterator[_S]):
    coords = ...  # type: ShapeType
    def copy(self) -> flatiter[_S]: ...


class ndarray(Generic[_S, _D], SupportsAbs['ndarray[_S, _D]'], Sized, Iterable):
    T = None         # type: ndarray[_S, _D]
    data = None      # type: Any
    dtype = None     # type: _dtype
    flags = None     # type: flagsobj
    flat = None      # type: flatiter[_S]
    imag = None      # type: ndarray[_S, _D]
    real = None      # type: ndarray[_S, _D]
    size = None      # type: int
    itemsize = None  # type: int
    nbytes = None    # type: int
    ndim = None      # type: int
    shape = None     # type: Tuple[int, ...]
    strides = None   # type: Tuple[int, ...]
    base = None      # type: Optional[ndarray[_S, _D]]

    # "only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`)
    # and integer or boolean arrays are valid indices"
    # FIXME: missing some
    def __getitem__(self, key: IndexType) -> 'ndarray[_S, Any]': ...
    def __setitem__(self, key: IndexType, value: Union[scalar, 'ndarray']) -> None: ...


    def __add__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __radd__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __sub__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __rsub__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __mul__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __rmul__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __div__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __rdiv__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __floordiv__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __rfloordiv__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __truediv__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __rtruediv__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...

    def __le__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __lt__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __ge__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __gt__(self, value: Union[int, float, 'ndarray[Any, Any]']) -> 'ndarray[Any, Any]': ...
    def __eq__(self, value: object) -> bool: ...  # fixed in plugin


    def __contains__(self, value: Union[int, float, bool]) -> bool: ...

    def copy(self, order: str='C') -> 'ndarray[_S, _D]': ...
    # Incomplete
    def all(self, axis: AxesType=None, keepdims: bool=False) -> 'ndarray[bool, _InferNdimsReduction]': ...
    def swapaxes(self, axis1: int, axis2: int) -> 'ndarray[_S, _D]': ...
    def astype(self, dtype: DtypeType) -> 'ndarray[_InferDtype, _D]': ...
    def fill(self, a: scalar) -> None: ...
    def reshape(self, shape: ShapeType, order: str='C') -> 'ndarray[_S, _InferNdimsFromShape]': ...



array1d = ndarray[_S, OneD]
array2d = ndarray[_S, TwoD]
array3d = ndarray[_S, ThreeD]
array4d = ndarray[_S, FourD]
array_float = ndarray[float, _D]
array_like = TypeVar('array_like', ndarray, float, int)

float32 = float
float64 = float
int32 = int
int64 = int

###############################################################################
# numpy.core.multiarray:
#   count_nonzero,  datetime_as_string,  datetime_data,  digitize,  dot,  einsum,  empty,  empty_like,  fastCopyAndTranspose,  frombuffer,  fromfile,  fromiter,  fromstring,  inner,  int_asbuffer,  is_busday,  lexsort,  matmul,  may_share_memory,  min_scalar_type,  nested_iters,  packbits,  promote_types,  putmask,  ravel_multi_index,  result_type,  set_numeric_ops,  shares_memory,  unpackbits,  unravel_index,  vdot,  where,  zeros

def arange(start: int, stop: int=0, step: int=0, dtype: DtypeType=float) -> array1d[_InferDtypeWithDefault[float]]: ...
def array(object: Iterable, dtype: DtypeType=None, copy: bool=True, order: str='K', subok: bool=False, ndim: int=0) -> ndarray[_InferDtypeWithDefault[Any], Any]: ...
def asarray(object: Iterable, dtype: DtypeType=None) -> ndarray[_InferDtypeWithDefault[Any], Any]: ...
def ascontiguousarray(object: Iterable, dtype: DtypeType=None) -> ndarray[_InferDtypeWithDefault[Any], Any]: ...
def bincount(x: array1d[int], weights: array1d[_S]=None, minlength: int=None) -> array1d[int]: ...
def can_cast(fromtype: Any, totype: Any, casting: str = 'safe') -> bool: ...
def concatenate(tup: Iterable[ndarray[_S, _D]], axis: int=None) -> ndarray[_S, _D]: ...
def copyto(dst: ndarray[_S, _D], src: ndarray[_S, _D], casting: str='same_kind', where: ndarray[bool, _D1]=None) -> None: ...


def zeros(shape: ShapeType, dtype: DtypeType=float, order: str='C') -> ndarray[_InferDtypeWithDefault[float], _InferNdimsFromShape]: ...
def ones(shape: ShapeType, dtype: DtypeType=float, order: str='C') -> ndarray[_InferDtypeWithDefault[float], _InferNdimsFromShape]: ...
def empty(shape: ShapeType, dtype: DtypeType=float, order: str='C') -> ndarray[_InferDtypeWithDefault[float], _InferNdimsFromShape]: ...
def full(shape: ShapeType, fill_value: scalar, dtype: DtypeType=float, order: str='C') -> ndarray[_InferDtypeWithDefault[float], _InferNdimsFromShape]: ...
def ones_like(a: ndarray[_S, _D], dtype: DtypeType=None, order: str='K') -> ndarray[_InferDtypeWithDefault[_S], _D]: ...
def zeros_like(a: ndarray[_S, _D], dtype: DtypeType=None, order: str='K') -> ndarray[_InferDtypeWithDefault[_S], _D]: ...
def empty_like(a: ndarray[_S, _D], dtype: DtypeType=None, order: str='K') -> ndarray[_InferDtypeWithDefault[_S], _D]: ...
# FIXME: dtype of fill value takes priority over dtype arg.
def full_like(a: ndarray[_S, _D], fill_value: scalar, dtype: DtypeType=float, order: str='K') -> ndarray[_InferDtypeWithDefault[_S], _D]: ...
def average(a: ndarray[_S, _D], axis: AxisType=None, weights: ndarray[_S1, _D1]=None, returned: bool=False) -> ndarray[float, _InferNdimsIfAxisSpecified[ZeroD, _LowerDim[_D]]]: ...

###############################################################################

# ufuncs:
def abs(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def absolute(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def add(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def arccos(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def arccosh(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def arcsin(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def arcsinh(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def arctan(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def arctan2(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def arctanh(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def bitwise_and(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def bitwise_not(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def bitwise_or(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def bitwise_xor(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def cbrt(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def ceil(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def conj(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def conjugate(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def copysign(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def cos(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def cosh(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def deg2rad(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def degrees(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def divide(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def equal(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def exp(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def exp2(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def expm1(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def fabs(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def floor(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def floor_divide(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def fmax(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def fmin(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def fmod(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def frexp(x: Union[scalar, ndarray[_S, _D]], out1: ndarray=None, out2: ndarray=None) -> Tuple[ndarray[float, _LargestDim[_D, ZeroD]], ndarray[int, _LargestDim[_D, ZeroD]]]: ...
def greater(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def greater_equal(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def hypot(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def invert(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def isfinite(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def isinf(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def isnan(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def ldexp(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def left_shift(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def less(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def less_equal(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def log10(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def log1p(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def log2(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def log(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def logaddexp2(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def logaddexp(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def logical_and(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def logical_not(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def logical_or(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def logical_xor(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def maximum(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def minimum(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def mod(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def modf(x: Union[scalar, ndarray[_S, _D]], out1: ndarray=None, out2: ndarray=None) -> Tuple[ndarray[float, _LargestDim[_D, ZeroD]], ndarray[float, _LargestDim[_D, ZeroD]]]: ...
def multiply(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def negative(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def nextafter(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def not_equal(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def power(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def rad2deg(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def radians(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def reciprocal(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def remainder(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def right_shift(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def rint(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def sign(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def signbit(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def sin(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def sinh(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def spacing(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def sqrt(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def square(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def subtract(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def tan(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def tanh(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...
def true_divide(x1: Union[scalar, ndarray[_S, _D]], x2: Union[scalar, ndarray[_S1, _D1]], out: ndarray=None) -> ndarray[_UfuncCast[_S, _S1], _LargestDim[_D, _D1]]: ...
def trunc(x: Union[scalar, ndarray[_S, _D]], out: ndarray=None) -> ndarray[_UfuncCast, _LargestDim[_D, ZeroD]]: ...


###############################################################################

# numpy.lib.shape_base
def stack(tup: Iterable[ndarray[_S, _D]], axis: int=None) -> ndarray[_S, _RaiseDim[_D]]: ...
#def hstack(tup: Iterable[ndarray[_S, _D]]) -> ndarray[_S, _RaiseDim[_D]]: ...
#def vstack(tup: Iterable[ndarray[_S, _D]]) -> ndarray[_S, _RaiseDim[_D]]: ...
#def dstack(tup: Iterable[ndarray[_S, _D]]) -> ndarray[_S, _RaiseDim[_D]]: ...
def split(a: ndarray[_S, _D], indices_or_sections: Union[int, Sequence[int]], axis: AxisType=0) -> Tuple[ndarray[_S, _D], ...]: ...
def hsplit(a: ndarray[_S, _D], indices_or_sections: Union[int, Sequence[int]]) -> Tuple[ndarray[_S, _D], ...]: ...
def vsplit(a: ndarray[_S, _D], indices_or_sections: Union[int, Sequence[int]]) -> Tuple[ndarray[_S, _D], ...]: ...
def dsplit(a: ndarray[_S, _D], indices_or_sections: Union[int, Sequence[int]]) -> Tuple[ndarray[_S, _D], ...]: ...

###############################################################################
# numpy.core.fromnumeric
# missing = searchsorted, sort, take, 
def alen(a: ndarray[_S, _D]) -> int: ...
def all(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[bool, _InferNdimsReduction[_D]]: ...
def alltrue(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[bool, _InferNdimsReduction[_D]]: ...
def amin(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[_S, _InferNdimsReduction[_D]]: ...
def amax(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[_S, _InferNdimsReduction[_D]]: ...
def any(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[bool, _InferNdimsReduction[_D]]: ...
def argmax(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None) -> ndarray[int, _InferNdimsReduction[_D]]: ...
def argmin(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None) -> ndarray[int, _InferNdimsReduction[_D]]: ...
# def argpartition(a: ndarray[_S, _D], axis: AxisType=-1, kth=Union[int, Sequence[int]], kind: str='introselect', order: Union[str, Sequence[str]]=None) -> ndarray[int, _D]: ...
def argsort(a: ndarray[_S, _D], axis: AxisType=-1, kind: str='introselect', order: Union[str, Sequence[str]]=None) -> ndarray[int, _D]: ...
def around(a: ndarray[_S, _D], decimals: int=0, out: ndarray=None) -> ndarray[_S, _D]: ...
def choose(a: ndarray[int, Any], choices: Sequence[ndarray[Any, _D]], mode: str='raise') -> ndarray[Any, _D]: ...
def clip(a: ndarray[_S, _D], a_min: array_like, a_max: array_like, out: ndarray=None) -> ndarray[_S, _D]: ...
def compress(condition: array1d[bool], a: array_like, axis: int=None, out: ndarray=None) -> ndarray[Any, Any]: ...
def cumprod(a: ndarray[_S, _D], axis: AxesType=None, dtype: DtypeType=None, out: ndarray=None) -> ndarray[_InferDtypeWithDefault[_S], _InferNdimsIfAxisSpecified[OneD, _D]]: ...
def cumproduct(a: ndarray[_S, _D], axis: AxesType=None, dtype: DtypeType=None, out: ndarray=None) -> ndarray[_InferDtypeWithDefault[_S], _InferNdimsIfAxisSpecified[OneD, _D]]: ...
def cumsum(a: ndarray[_S, _D], axis: AxesType=None, dtype: DtypeType=None, out: ndarray=None) -> ndarray[_InferDtypeWithDefault[_S], _InferNdimsIfAxisSpecified[OneD, _D]]: ...
def diagonal(a: ndarray[_S, _D], offset: int=0, axis1: int=0, axis2: int=1) -> ndarray[_S, _LowerDim[_D]]: ...
def max(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[_S, _InferNdimsReduction[_D]]: ...
def mean(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[_S, _InferNdimsReduction[_D]]: ...
def ndim(a: ndarray[_S, _D]) -> int: ...
# FIXME: nonzero: Incomplete: length of tuple is _D
def nonzero(a: ndarray[_S, _D]) -> Tuple[ndarray[int, OneD], ...]: ...
# def partition(a: ndarray[_S, _D], axis: AxisType=-1, kth=Union[int, Sequence[int]], kind: str='introselect', order: Union[str, Sequence[str]]=None) -> ndarray[_S, _D]: ...
def prod(a: ndarray[_S, _D], axis: AxesType=None, dtype: DtypeType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[_InferDtypeWithDefault[_S], _InferNdimsReduction[_D]]: ...
def product(a: ndarray[_S, _D], axis: AxesType=None, dtype: DtypeType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[_InferDtypeWithDefault[_S], _InferNdimsReduction[_D]]: ...
def ptp(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None) -> ndarray[_S, _InferNdimsReduction[_D]]: ...
def put(a: ndarray[_S, _D], ind: array_like, v: array_like, mode: str='raise') -> None: ...
def rank(a: ndarray[_S, _D]) -> int: ...
def ravel(a: ndarray[_S, _D], order: str='C') -> ndarray[_S, OneD]: ...
def repeat(a: ndarray[_S, _D], repeats: Union[int, ndarray[int, Any]], axis: AxisType=None) -> ndarray[_S, _RaiseDim[_D]]: ...
def reshape(a: ndarray[_S, _D], newshape: ShapeType, order: str='C') -> ndarray[_S, _InferNdimsFromShape]: ...
def resize(a: ndarray[_S, _D], newshape: ShapeType) -> ndarray[_S, _InferNdimsFromShape]: ...
def round(a: ndarray[_S, _D], decimals: int=0, out: ndarray=None) -> ndarray[_S, _D]: ...
# FIXME: shape: Incomplete: length of tuple is _D
def shape(a: ndarray[_S, _D]) -> Tuple[int, ...]: ...
def size(a: ndarray[_S, _D], axis: AxisType=None) -> int: ...
def sometrue(a: ndarray[_S, _D], axis: AxesType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[bool, _InferNdimsReduction[_D]]: ...
def squeeze(a: ndarray[_S, _D], axis: AxesType=None) -> ndarray[_S, Any]: ...
def std(a: ndarray[_S, _D], axis: AxesType=None, dtype: DtypeType=None, out: ndarray=None, ddof: int=0, keepdims: bool=False) -> ndarray[_InferDtypeWithDefault[_S], _InferNdimsReduction[_D]]: ...
def sum(a: ndarray[_S, _D], axis: AxesType=None, dtype: DtypeType=None, out: ndarray=None, keepdims: bool=False) -> ndarray[_InferDtypeWithDefault[_S], _InferNdimsReduction[_D]]: ...
def swapaxes(a: ndarray[_S, _D], axis1: int, axis2: int) -> ndarray[_S, _D]: ...
def trace(a: ndarray[_S, _D], offset: int=0, axis1: int=0, axis2: int=1, dtype: DtypeType=None, out: ndarray=None) -> ndarray[_InferDtypeWithDefault[_S], _LowerDim2[_D]]: ...
def transpose(a: ndarray[_S, _D], axes: Sequence[int]=None) -> ndarray[_S, _D]: ...
def var(a: ndarray[_S, _D], axis: AxesType=None, dtype: DtypeType=None, out: ndarray=None, ddof: int=0, keepdims: bool=False) -> ndarray[_InferDtypeWithDefault[_S], _InferNdimsReduction[_D]]: ...

###############################################################################


def isclose(a: ndarray[_S, _D], b: ndarray[_S, _D], rtol: float=1e-05, atol: float=1e-08, equal_nan: bool=False) -> ndarray[bool, _D]: ...
def allclose(a: ndarray[_S, _D], b: ndarray[_S, _D], rtol: float=1e-05, atol: float=1e-08, equal_nan: bool=False) -> bool: ...

# numpy.lib.type_check
def nan_to_num(a: ndarray[_S, _D]) -> ndarray[_S, _D]: ...

def diag(a: ndarray[_S, _D]) -> ndarray[_S, _ToggleDims_12_21[_D]]: ...

# @overload
# def diag(a: array1d[float]) -> array2d[float]: ...
# @overload
# def diag(a: array2d[float]) -> array1d[float]: ...

# Incomplete
def einsum(subscripts: str, *operands: ndarray[_S, Any], out: ndarray[_S, Any]=None, dtype: DtypeType=None, order: str='K', casting: str='safe') -> ndarray[Any, Any]: ...

# Incomplete
# def ix_(*args: ndarray[_S, OneD]) -> Tuple[ndarray[_S, Any], ...]: ...
@overload
def ix_(iter1: ndarray[_S, OneD]) -> Tuple[ndarray[_S, OneD]]: ...
@overload
def ix_(iter1: ndarray[_S, OneD], iter2: ndarray[_S, OneD]) -> Tuple[ndarray[_S, OneD], ndarray[_S, OneD]]: ...


def eye(N: int, M: int=None, k: int=0, dtype: DtypeType=float) -> ndarray[float, TwoD]: ...



@overload
def where(condition: ndarray[bool, _D]) -> Tuple[ndarray[int, OneD], ...]: ...
@overload
def where(condition: ndarray[bool, _D], x: ndarray[_S, _D], y: ndarray[_S, _D]) -> ndarray[_S, _D]: ...


def insert(arr: ndarray[_S, _D], obj: Union[int, ndarray[int, OneD]], values: Union[int, float, bool, ndarray[_S, _D]], axis: int=None) -> ndarray[_S, _D]: ...
def append(arr: ndarray[_S, _D], values: Union[int, float, bool, ndarray[_S, _D]], axis: int=None) -> ndarray[_S, _D]: ...

def fromstring(string: Text, dtype: DtypeType=float, count: int=-1, sep: Text='') -> ndarray[Any, OneD]: ...


nan = ... # type: float
inf = ... # type: float
pi = ... # type: float
newaxis = ... # type: None


class linalg:
    @staticmethod
    def cholesky(a: ndarray[Any, TwoD]) -> ndarray[float, TwoD]: ...

    @staticmethod
    def eigh(a: ndarray[Any, _D]) -> Tuple[ndarray[float, _LowerDim[_D]], ndarray[float, _D]]: ...


class finfo:
    def __init__(self, dtype: DtypeType=None) -> None: ...
    eps = None  # type: float
    min = None  # type: float
    max = None  # type: float


class testing:
    @overload
    @staticmethod
    def assert_allclose(actual: ndarray[_S, _D], desired: ndarray[_S, _D], rtol: float=None, atol: float=None, equal_nan: bool=None, err_msg: str='', verbose: bool=False) -> None: ...

    @overload
    @staticmethod
    def assert_allclose(actual: float, desired: float, rtol: float=None, atol: float=None, equal_nan: bool=None, err_msg: str='', verbose: bool=False) -> None: ...